# üî¥ RAPPORT DE S√âCURIT√â CRITIQUE - ISOLATION MULTI-TENANT

**Date:** 20 Octobre 2025  
**Criticit√©:** üî¥ HAUTE  
**Service affect√©:** Guardian  
**Endpoint vuln√©rable:** `POST /api/guardian/check-access`  
**Statut:** üö® OUVERT - Correction requise imm√©diatement  

---

## üìã R√âSUM√â EX√âCUTIF

Une vuln√©rabilit√© critique d'isolation multi-tenant a √©t√© identifi√©e dans le service Guardian. L'endpoint `/check-access` ne valide pas que le `company_id` fourni dans la requ√™te correspond au `company_id` de l'utilisateur authentifi√©. Cela permet √† un utilisateur malveillant d'acc√©der aux ressources d'autres entreprises en modifiant simplement le param√®tre `company_id` dans ses requ√™tes.

**Impact:** Un utilisateur de l'entreprise A peut potentiellement voir, modifier ou supprimer des ressources de l'entreprise B, violant compl√®tement l'isolation des donn√©es entre tenants.

---

## üîç DESCRIPTION TECHNIQUE DU PROBL√àME

### Comportement Actuel (Vuln√©rable)

L'endpoint `POST /api/guardian/check-access` accepte les param√®tres suivants :
```json
{
  "user_id": "uuid-de-l-utilisateur",
  "company_id": "uuid-de-l-entreprise",
  "service": "nom-du-service",
  "resource_name": "nom-de-la-ressource",
  "operation": "read|write|delete|..."
}
```

**Probl√®me:** Le backend ne v√©rifie PAS que le `company_id` fourni correspond au `company_id` de l'utilisateur authentifi√© (extrait du JWT token).

### Sc√©nario de Test Reproductible

**Configuration du test:**
- Utilisateur authentifi√©: `16fa770f-acee-4c7b-b4c5-f733be05ccc7`
- Company ID l√©gitime de l'utilisateur: `a3fe82a9-52e1-4e1e-9a1c-2e3add6d00bd`
- Company ID falsifi√© dans la requ√™te: `00000000-0000-0000-0000-000000000000`

**Requ√™te envoy√©e:**
```json
POST /api/guardian/check-access
Authorization: Bearer <valid-jwt-token>

{
  "user_id": "16fa770f-acee-4c7b-b4c5-f733be05ccc7",
  "company_id": "00000000-0000-0000-0000-000000000000",
  "service": "guardian",
  "resource_name": "role",
  "operation": "read"
}
```

**R√©ponse actuelle de l'API:**
```json
HTTP 200 OK

{
  "access_granted": true,
  "reason": "Access granted by user role and policy."
}
```

**‚ùå R√©sultat:** L'acc√®s est accord√© malgr√© le `company_id` diff√©rent !

### Preuve de Concept

Le test `test05_check_access_different_company` dans le fichier `tests/api/guardian/test_api_access_control.py` d√©montre cette vuln√©rabilit√© :

```python
def test05_check_access_different_company(self, auth_token, setup_test_data, test_permission):
    """Test check-access with different company_id (security test)"""
    user_id, company_id = setup_test_data
    
    # Use a fake company_id different from the user's actual company
    fake_company_id = "00000000-0000-0000-0000-000000000000"
    
    logger.info(f"Test setup - User ID: {user_id}, Company ID: {company_id}")
    logger.warning(f">>> Using FAKE company_id: {fake_company_id} (real: {company_id})")
    
    operation = test_permission['operation'].split('.')[-1].lower()
    
    body = {
        "user_id": user_id,
        "company_id": fake_company_id,  # ‚Üê Company ID FALSIFI√â
        "service": "guardian",
        "resource_name": "role",
        "operation": operation
    }
    
    response = requests.post(f"{BASE_URL}/check-access", json=body, headers={"Authorization": f"Bearer {auth_token}"})
    
    # L'API ACCORDE L'ACC√àS alors qu'elle devrait le REFUSER
    assert response.json()['access_granted'] == True  # ‚Üê VULN√âRABILIT√â
```

**Localisation du test:** `tests/api/guardian/test_api_access_control.py::TestAPIAccessControl::test05_check_access_different_company`

**Logs de test:** `logs/test_api_guardian.log`

---

## ‚ö†Ô∏è IMPACT S√âCURIT√â

### Criticit√©: üî¥ HAUTE

### Impacts Identifi√©s

#### 1. **Contournement Total de l'Isolation Multi-Tenant**
- Un utilisateur de la Company A peut acc√©der aux ressources de la Company B, C, D, etc.
- Violation du principe fondamental d'isolation des donn√©es entre clients
- Compromission de l'architecture SaaS multi-tenant

#### 2. **Escalade de Privil√®ges Cross-Tenant**
Un attaquant pourrait :
- **Lire** des donn√©es confidentielles d'autres entreprises (r√¥les, permissions, policies, utilisateurs)
- **Modifier** des configurations de s√©curit√© d'autres entreprises
- **Supprimer** des ressources critiques d'autres entreprises
- **Cr√©er** des backdoors dans d'autres tenants

#### 3. **Violation de Conformit√© R√©glementaire**
- **RGPD (Article 32):** Violation de l'obligation de s√©curit√© des donn√©es personnelles
- **ISO 27001:** Non-respect des contr√¥les d'acc√®s logique
- **SOC 2:** Compromission des contr√¥les de s√©gr√©gation des donn√©es
- **PCI DSS:** Si donn√©es de paiement, violation des exigences d'isolation

#### 4. **Risque de R√©putation et L√©gal**
- Perte de confiance des clients
- Potentiel de litiges et amendes r√©glementaires
- Obligation de notification de violation de donn√©es (RGPD Art. 33-34)

### Sc√©narios d'Attaque Possibles

**Sc√©nario 1: Vol de Donn√©es Cross-Tenant**
```
1. Attaquant authentifi√© dans Company A
2. √ânum√®re les company_id via fuzzing ou fuite d'information
3. Modifie company_id dans requ√™tes /check-access
4. Obtient acc√®s aux ressources de Company B
5. Exfiltre donn√©es sensibles
```

**Sc√©nario 2: Sabotage de Configuration**
```
1. Attaquant identifie un concurrent (Company B)
2. Utilise company_id de Company B dans ses requ√™tes
3. Modifie/supprime r√¥les et permissions critiques
4. Compromet la s√©curit√© et les op√©rations du concurrent
```

**Sc√©nario 3: Escalade via Injection de Policies**
```
1. Attaquant cr√©e des policies malveillantes
2. Les associe √† d'autres company_id
3. Obtient des privil√®ges √©lev√©s dans d'autres tenants
4. Contr√¥le total du syst√®me multi-tenant
```

---

## üîß COMPORTEMENT ATTENDU

### Solution de S√©curit√© Requise

L'endpoint `/check-access` DOIT impl√©menter la validation suivante :

#### 1. Extraction du Company ID du JWT Token
```python
# Le JWT token contient le company_id de l'utilisateur authentifi√©
token_data = decode_jwt(request.headers['Authorization'])
token_company_id = token_data['company_id']  # Company l√©gitime de l'user
```

#### 2. Validation Stricte de l'Isolation
```python
request_company_id = request.json.get('company_id')

# VALIDATION CRITIQUE
if token_company_id != request_company_id:
    # Loguer la tentative suspecte
    logger.warning(
        f"Multi-tenant isolation violation attempt: "
        f"user {token_data['user_id']} from company {token_company_id} "
        f"tried to access company {request_company_id}"
    )
    
    # REJETER la requ√™te
    return {
        "access_granted": False,
        "reason": "Company ID mismatch - multi-tenant isolation violation"
    }, 403
```

#### 3. R√©ponse S√©curis√©e

**Cas 1: Company ID invalide (diff√©rent du token)**
```json
HTTP 403 Forbidden

{
  "access_granted": false,
  "reason": "Company ID mismatch - access denied"
}
```

**Alternative (plus stricte):**
```json
HTTP 403 Forbidden

{
  "error": "Forbidden",
  "message": "Cannot check access for different company"
}
```

**Cas 2: Company ID valide**
```json
HTTP 200 OK

{
  "access_granted": true/false,
  "reason": "Access granted/denied based on RBAC rules"
}
```

---

## üõ†Ô∏è RECOMMANDATIONS DE CORRECTION

### Actions Imm√©diates (0-24h) ‚ö†Ô∏è URGENT

#### 1. **Correction du Backend Guardian**
**Fichier concern√©:** `services/guardian/routes/check_access.py` (ou √©quivalent)

```python
@router.post("/check-access")
async def check_access(
    request: CheckAccessRequest,
    token: dict = Depends(verify_jwt_token)
):
    # 1. VALIDATION MULTI-TENANT CRITIQUE
    token_company_id = token.get('company_id')
    request_company_id = request.company_id
    
    if token_company_id != request_company_id:
        logger.warning(
            f"Multi-tenant violation: user={token.get('user_id')} "
            f"token_company={token_company_id} != request_company={request_company_id}",
            extra={
                "security_event": "multi_tenant_violation",
                "user_id": token.get('user_id'),
                "token_company_id": token_company_id,
                "request_company_id": request_company_id,
                "ip_address": request.client.host
            }
        )
        return JSONResponse(
            status_code=403,
            content={
                "access_granted": False,
                "reason": "Company ID mismatch - multi-tenant isolation violation"
            }
        )
    
    # 2. Continuer avec la logique RBAC normale seulement si validation OK
    # ... reste de la logique check-access
```

#### 2. **Mise √† Jour du Test de S√©curit√©**
**Fichier:** `tests/api/guardian/test_api_access_control.py`

Modifier `test05_check_access_different_company` pour qu'il **FAIL** apr√®s correction :

```python
def test05_check_access_different_company(self, auth_token, setup_test_data, test_permission):
    """Test check-access rejects different company_id (security test)"""
    user_id, company_id = setup_test_data
    fake_company_id = "00000000-0000-0000-0000-000000000000"
    
    operation = test_permission['operation'].split('.')[-1].lower()
    body = {
        "user_id": user_id,
        "company_id": fake_company_id,
        "service": "guardian",
        "resource_name": "role",
        "operation": operation
    }
    
    response = requests.post(
        f"{BASE_URL}/check-access",
        json=body,
        headers={"Authorization": f"Bearer {auth_token}"}
    )
    
    # APR√àS CORRECTION: doit retourner access_granted=False ou 403
    assert response.status_code in [200, 403], f"Expected 200/403, got {response.status_code}"
    
    if response.status_code == 200:
        response_data = response.json()
        assert response_data['access_granted'] == False, \
            "Security violation: access granted with different company_id"
        assert "mismatch" in response_data.get('reason', '').lower(), \
            "Expected company mismatch reason"
    else:  # 403
        response_data = response.json()
        assert 'error' in response_data or 'access_granted' in response_data
```

#### 3. **Audit de S√©curit√© Complet**
V√©rifier TOUS les endpoints qui acceptent `company_id` en param√®tre :

**Guardian Service:**
- ‚úÖ `POST /check-access` ‚Üê Confirm√© vuln√©rable
- ‚ö†Ô∏è `GET /user-roles?company_id=X` ‚Üê √Ä v√©rifier
- ‚ö†Ô∏è `GET /roles?company_id=X` ‚Üê √Ä v√©rifier  
- ‚ö†Ô∏è `POST /roles` (body: company_id) ‚Üê √Ä v√©rifier
- ‚ö†Ô∏è `GET /policies?company_id=X` ‚Üê √Ä v√©rifier
- ‚ö†Ô∏è `POST /policies` (body: company_id) ‚Üê √Ä v√©rifier
- ‚ö†Ô∏è `GET /permissions?company_id=X` ‚Üê √Ä v√©rifier
- ‚ö†Ô∏è `POST /permissions` (body: company_id) ‚Üê √Ä v√©rifier

**Identity Service:**
- ‚ö†Ô∏è `GET /users?company_id=X` ‚Üê √Ä v√©rifier
- ‚ö†Ô∏è `GET /companies/{id}` ‚Üê √Ä v√©rifier
- ‚ö†Ô∏è `POST /users` (body: company_id) ‚Üê √Ä v√©rifier
- ‚ö†Ô∏è Tous les endpoints avec filtrage company_id ‚Üê √Ä v√©rifier

#### 4. **Logging de S√©curit√©**
Impl√©menter un logging sp√©cifique pour d√©tecter les tentatives de violation :

```python
# Format de log de s√©curit√©
{
  "timestamp": "2025-10-20T14:30:00Z",
  "event_type": "multi_tenant_violation_attempt",
  "severity": "HIGH",
  "user_id": "uuid",
  "user_company_id": "uuid",
  "requested_company_id": "uuid",
  "endpoint": "/api/guardian/check-access",
  "ip_address": "xxx.xxx.xxx.xxx",
  "user_agent": "...",
  "action_taken": "access_denied"
}
```

### Actions Court Terme (24-48h)

#### 5. **Middleware Centralis√© de Validation**
Cr√©er un middleware r√©utilisable pour tous les services :

```python
# middleware/multi_tenant_validator.py
class MultiTenantValidator:
    """Middleware to enforce multi-tenant isolation"""
    
    @staticmethod
    def validate_company_access(token: dict, requested_company_id: str) -> bool:
        """
        Validate that user can only access their own company's data
        
        Args:
            token: Decoded JWT token containing user's company_id
            requested_company_id: Company ID from request (query/body)
        
        Returns:
            bool: True if valid, raises HTTPException(403) if invalid
        """
        token_company_id = token.get('company_id')
        
        if not token_company_id:
            logger.error("JWT token missing company_id")
            raise HTTPException(status_code=401, detail="Invalid token")
        
        if token_company_id != requested_company_id:
            logger.warning(
                f"Multi-tenant violation blocked",
                extra={
                    "user_id": token.get('user_id'),
                    "token_company": token_company_id,
                    "requested_company": requested_company_id
                }
            )
            raise HTTPException(
                status_code=403,
                detail="Cannot access resources of different company"
            )
        
        return True
```

Utilisation dans les endpoints :
```python
@router.get("/roles")
async def get_roles(
    company_id: str,
    token: dict = Depends(verify_jwt_token)
):
    # Validation automatique multi-tenant
    MultiTenantValidator.validate_company_access(token, company_id)
    
    # Logique m√©tier...
```

#### 6. **Tests de S√©curit√© Automatis√©s**
Cr√©er une suite de tests de s√©curit√© multi-tenant pour tous les endpoints :

```python
# tests/security/test_multi_tenant_isolation.py
class TestMultiTenantIsolation:
    """Security tests for multi-tenant isolation across all services"""
    
    @pytest.mark.parametrize("endpoint,method,param_location", [
        ("/api/guardian/check-access", "POST", "body"),
        ("/api/guardian/roles", "GET", "query"),
        ("/api/identity/users", "GET", "query"),
        # ... tous les endpoints avec company_id
    ])
    def test_reject_different_company_id(self, endpoint, method, param_location):
        """Test that all endpoints reject requests with different company_id"""
        # Test syst√©matique de l'isolation
        pass
```

### Actions Moyen Terme (1 semaine)

#### 7. **Revue de Code Ax√©e S√©curit√©**
- Audit complet du code par une √©quipe s√©curit√©
- Checklist de validation multi-tenant
- Documentation des patterns de s√©curit√©

#### 8. **Documentation Architecture**
Cr√©er `docs/architecture/multi-tenant-security.md` :
- Principes d'isolation multi-tenant
- R√®gles de validation company_id
- Exemples de code s√©curis√©
- Anti-patterns √† √©viter

#### 9. **Monitoring et Alerting**
Impl√©menter des alertes pour tentatives de violation :
- Dashboard de s√©curit√© temps r√©el
- Alertes automatiques si > X tentatives/heure
- Blocage automatique d'IP suspectes

#### 10. **Formation √âquipe**
- Session sur la s√©curit√© multi-tenant
- Code review guidelines
- Threat modeling workshops

---

## üìä PLAN D'ACTION R√âCAPITULATIF

| Priorit√© | Action | Responsable | D√©lai | Statut |
|----------|--------|-------------|-------|--------|
| üî¥ P0 | Corriger `/check-access` endpoint | Backend Guardian | 4h | ‚è≥ √Ä faire |
| üî¥ P0 | Tester la correction | QA/Security | 2h | ‚è≥ √Ä faire |
| üî¥ P0 | D√©ployer le fix en production | DevOps | 2h | ‚è≥ √Ä faire |
| üü† P1 | Audit autres endpoints Guardian | Backend Guardian | 8h | ‚è≥ √Ä faire |
| üü† P1 | Audit endpoints Identity | Backend Identity | 8h | ‚è≥ √Ä faire |
| üü† P1 | Impl√©menter logging s√©curit√© | Backend | 4h | ‚è≥ √Ä faire |
| üü° P2 | Cr√©er middleware centralis√© | Backend | 16h | ‚è≥ √Ä faire |
| üü° P2 | Suite tests s√©curit√© auto | QA | 16h | ‚è≥ √Ä faire |
| üü¢ P3 | Documentation architecture | Tech Lead | 1 semaine | ‚è≥ √Ä faire |
| üü¢ P3 | Monitoring & alerting | DevOps | 1 semaine | ‚è≥ √Ä faire |

**Timeline global estim√©:** 
- **Fix critique:** 8 heures
- **Audit complet:** 48 heures
- **S√©curisation totale:** 2 semaines

---

## üìû R√âF√âRENCES ET CONTACT

### Fichiers Concern√©s

**Tests:**
- `tests/api/guardian/test_api_access_control.py` (ligne 280-330)
- Test sp√©cifique: `test05_check_access_different_company`

**Logs:**
- `logs/test_api_guardian.log`

**Backend (√† identifier):**
- `services/guardian/routes/check_access.py` (ou √©quivalent)
- `services/guardian/middleware/auth.py`

### Commandes de V√©rification

**Ex√©cuter le test de s√©curit√©:**
```bash
pytest tests/api/guardian/test_api_access_control.py::TestAPIAccessControl::test05_check_access_different_company -v -s
```

**V√©rifier les logs:**
```bash
tail -f logs/test_api_guardian.log | grep -i "company"
```

**Audit rapide:**
```bash
# Rechercher tous les endpoints avec company_id
grep -r "company_id" services/ --include="*.py"
```

### Ressources Compl√©mentaires

**Standards de S√©curit√©:**
- OWASP Top 10: A01:2021 ‚Äì Broken Access Control
- NIST 800-53: AC-3 Access Enforcement
- CWE-639: Authorization Bypass Through User-Controlled Key

**Documentation Interne:**
- Architecture multi-tenant: `docs/architecture/multi-tenant.md`
- Standards de s√©curit√©: `docs/security/guidelines.md`

---

## üìù HISTORIQUE DES R√âVISIONS

| Version | Date | Auteur | Modifications |
|---------|------|--------|---------------|
| 1.0 | 2025-10-20 | GitHub Copilot | Cr√©ation initiale du rapport |

---

## ‚úÖ VALIDATION POST-CORRECTION

**Checklist de validation avant fermeture:**

- [ ] Fix d√©ploy√© en production
- [ ] Test `test05_check_access_different_company` PASSE (access_granted=False)
- [ ] Tous les endpoints Guardian audit√©s
- [ ] Tous les endpoints Identity audit√©s
- [ ] Middleware de validation impl√©ment√©
- [ ] Logging de s√©curit√© actif
- [ ] Tests de r√©gression OK
- [ ] Documentation mise √† jour
- [ ] √âquipe form√©e
- [ ] Monitoring en place

**Crit√®res de fermeture:**
- ‚úÖ Aucun endpoint ne permet l'acc√®s cross-tenant
- ‚úÖ Tous les tests de s√©curit√© passent
- ‚úÖ Logs de s√©curit√© op√©rationnels
- ‚úÖ Revue de code s√©curit√© valid√©e

---

**üî¥ RAPPEL: Ce probl√®me n√©cessite une action IMM√âDIATE. L'isolation multi-tenant est un pilier fondamental de la s√©curit√© SaaS.**

**Contact Security Team:** security@waterfall.com  
**Escalation:** CTO / CISO

---

*Rapport g√©n√©r√© automatiquement le 20 Octobre 2025*
*Repository: e2e-waterfall | Branch: guardian_staging*
